/*#
 * Copyright (C) 2021 Geon Technologies, LLC
 *
 * This file is part of vrtgen.
 *
 * vrtgen is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * vrtgen is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
#*/

{%- macro ref_getter(field, is_const, type_helper) %}
/**
 * @brief Returns a {{ 'const ' if is_const }}reference to {{ field.name }}
 * @return A {{ 'const ' if is_const }}reference to {{ field.name }}
{% if field.is_optional %}
 * @exception std::bad_optional_access if {{ field.name }} does not contain a value
{% endif %}
 */
{%   if field.is_optional %}
std::optional<{{ 'const ' if is_const }}{{ type_helper.value_type(field) }}>& {{ field.name }}(){{ ' const' if is_const }};
{%   else %}
{{ 'const ' if is_const }}{{ type_helper.value_type(field) }}& {{ field.name }}(){{ ' const' if is_const }};
{%   endif %}
{% endmacro %}

{%- macro const_ref_getter(field, type_helper) %}
{{ ref_getter(field, true, type_helper) }}
{% endmacro %}

{%- macro value_getter(field, type_helper) %}
/**
 * @brief Returns the value of {{ field.name }}
 * @return {{ field.name }}'s value
{% if field.is_optional %}
 * @exception std::bad_optional_access if {{ field.name }} does not contain a value
{% endif %}
 */
{%   if field.is_optional %}
std::optional<{{ type_helper.value_type(field) }}> {{ field.name }}() const;
{%   else %}
{{ type_helper.value_type(field) }} {{ field.name }}() const;
{%   endif %}
{% endmacro %}

{%- macro getters(field, type_helper) %}
{% if not type_helper.is_scalar(field) %}
{{ ref_getter(field, false, type_helper) | trim }}
{% else %}
{{ value_getter(field, type_helper) | trim }}
{% endif %}
{% endmacro %}

{%- macro setters(field, type_helper) %}
/**
 * @brief Set the value of {{ field.name }}
 * @param value Value to assign to {{ field.name }}
 */
void {{ field.name }}(const {{ type_helper.value_type(field) }}{{ '&' if not type_helper.is_scalar(field) }} value);
{% endmacro %}

{%- macro getters_and_setters(field, type_helper) %}
{{ getters(field, type_helper) | trim }}

{{ setters(field, type_helper) | trim }}
{% endmacro %}

/*#
 * Prologue function declarations
#*/
{%- macro prologue(packet, type_helper) %}
{{ const_ref_getter(packet.header, type_helper) | trim }}

{{ getters_and_setters(packet.header.packet_count, type_helper) | trim }}

{% if packet.stream_id.enabled %}
{{ getters_and_setters(packet.stream_id, type_helper) | trim }}

{% endif %}
{% if packet.class_id.enabled %}
{{ const_ref_getter(packet.class_id, type_helper) | trim }}

{% endif %}
{% if packet.timestamp.enabled %}
{%   if packet.timestamp.integer.enabled %}
{{ getters_and_setters(packet.timestamp.integer, type_helper) | trim }}

{%   endif %}
{%   if packet.timestamp.fractional.enabled %}
{{ getters_and_setters(packet.timestamp.fractional, type_helper) | trim }}

{%   endif %}
{% endif %}
{% endmacro %}

/*#
 * Command function declarations
#*/
{%- macro command(packet, type_helper) %}
{% if packet.cam.enabled %}
{{ const_ref_getter(packet.cam, type_helper) | trim }}

{% endif %}
{% if packet.message_id.enabled %}
{{ getters_and_setters(packet.message_id, type_helper) | trim }}

{% endif %}
{% if packet.controllee_id.enabled %}
{{ value_getter(packet.controllee_id, type_helper) | trim }}

{{ setters(packet.controllee_id, type_helper) | trim }}

{% endif %}
{% if packet.controller_id.enabled %}
{{ value_getter(packet.controller_id, type_helper) | trim }}

{{ setters(packet.controller_id, type_helper) | trim }}

{% endif %}
{% endmacro %}

/*#
 * CIF function declarations
#*/
{%- macro cif_functions(cif, type_helper) %}
{% for field in cif.fields if field.enabled %}
{{ getters_and_setters(field, type_helper) | trim }}

{%   if field.is_optional %}
/**
 * @brief If {{ field.name }} contains a value, destroy it
 */
void reset_{{ field.name }}();

{%   endif %}
{% endfor %}
{%  endmacro %}

{%- macro cif_enable_functions(cif, type_helper) %}
{% for field in cif.fields if field.enabled and not field.indicator_only %}
/**
 * @brief Check if {{ field.name }} is enabled in {{ cif.name }}
 * @return true if {{ field.name }} is enabled in {{ cif.name }}, otherwise false
 */
bool {{ field.name }}_enabled() const
{
    return m_{{ cif.name }}.{{ field.getter }}();
}

/**
 * @brief Check if {{ field.name }} is enabled in {{ cif.name }}
 * @param value Value to set {{ field.name }} in {{ cif.name }}
 */
void {{ field.name }}_enabled(bool value)
{
    m_{{ cif.name }}.{{ field.setter }}(value);
}
{% endfor %}
{% endmacro %}

{%- macro cif(packet, type_helper) %}
{% if packet.cif0.enabled %}
{{ const_ref_getter(packet.cif0, type_helper) | trim }}

{%   if packet.requires_cif_functions %}
{{ cif_functions(packet.cif0, type_helper) | trim }}
{%   elif packet.requires_cif_enable_functions %}
{{ cif_enable_functions(packet.cif0, type_helper) | trim }}
{%   endif %}

{% endif %}
{% if packet.cif1.enabled %}
{{ const_ref_getter(packet.cif1, type_helper) | trim }}

{%   if packet.requires_cif_functions %}
{{ cif_functions(packet.cif1, type_helper) | trim }}
{%   elif packet.requires_cif_enable_functions %}
{{ cif_enable_functions(packet.cif1, type_helper) | trim }}
{%   endif %}

{% endif %}
{% if packet.cif2.enabled %}
{{ const_ref_getter(packet.cif2, type_helper) | trim }}
{% endif %}
{% if packet.cif7.enabled %}
{{ const_ref_getter(packet.cif7, type_helper) | trim }}
{% endif %}
{% endmacro %}

/*#
 * Data packet function declarations
#*/
{%- macro data(packet, type_helper) %}
/**
 * @brief Get a span to the underlying payload vector
 * @return A const pointer to the underlying payload vector
 */
std::span<const uint8_t> payload() const;

/**
 * @brief Set the underlying payload vector data
 * @param data Data to assign to the payload vector
 * @param len Length of @param data in bytes
 */
void payload(std::span<const uint8_t> data);

/**
 * @brief Get the size of the underlying payload vector data
 * @return Number of bytes in the payload data
 */
std::size_t payload_size() const;

{% if packet.trailer.enabled %}
{{ const_ref_getter(packet.trailer, type_helper) | trim }}

{% for field in packet.trailer.fields if field.enabled and not field.indicator_only %}
{%   set value_type = type_helper.value_type(field) %}
/**
 * @brief Get the indicator value for the trailer's {{ field.name }} field
 * @return Optionally wrapped indicator value for {{ field.name }} if enabled, otherwise null optional
 */
std::optional<{{ value_type }}> {{ field.name }}() const;

/**
 * @brief Set the indicator value for the trailer's {{ field.name }} field
 * @param value Indicator value to assign to {{ field.name }}
 */
void {{ field.name }}(const {{ value_type }} value);

/**
 * @brief Reset the trailer's {{ field.name }} enable and indicator bits to zero
 */
void reset_{{ field.name }}();
{% endfor %}
{% endif %}
{% endmacro %}
