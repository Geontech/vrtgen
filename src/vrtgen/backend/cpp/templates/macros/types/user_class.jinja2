/*#
 * Copyright (C) 2021 Geon Technologies, LLC
 *
 * This file is part of vrtgen.
 *
 * vrtgen is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * vrtgen is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
#*/
{% import "macros/types/basic.jinja2" as basic %}

{%- macro define_class(class, type_helper) %}
{% set fields = (class.fields | sort_packed_tags) %}
/**
{% for line in (class.__doc__ | format_docstring) %}
 * {{ line | trim }}
{% endfor %}
 */
 {% if class.is_template %}
template < typename {{ class.template_name }} >
 {% endif %}
class {{ class.type_ }} {% if class.child_of %} : public vrtgen::packing::{{ class.child_of }} {% endif %}
{
public:
{% for field in fields if field.enabled and not field.is_packed_type %}
{% set packed = field.packed_tag.packed_int is not none and field.user_defined %}
{% if class.child_of or field.is_extension_type %}
{%   if field.packed_tag.packed_int is not none and field.user_defined %}
    {{ basic.getters_and_setters(field, type_helper, packed) | indent(4) | trim }}
{%   endif %}
{% else %}
    {{ basic.getters_and_setters(field, type_helper) | indent(4) | trim }}
{% endif %}
{% endfor %}
{% if not class.child_of %}
    size_t size() const
    {
        size_t retval = 0;
{% for field in fields if field.enabled and field.packed_tag.packed_int is none %}
{%   if type_helper.is_scalar(field) %}
        retval += sizeof({{ type_helper.member_type(field) }}); // {{ field.name }}
{%   else %}
{%     if field.is_list %}
        for (const auto{{ '&' if not type_helper.is_scalar(field.type_) }} elem : _{{ field.name }}) {
{%       if not type_helper.is_scalar(field.type_) %}
            retval += elem.size();
{%       else %}
            retval += sizeof(elem);
{%       endif %}
        }
{%     else %}
        retval += _{{ field.name }}.size();
{%     endif %}
{%   endif %}
{% endfor %}
        return retval;
    }

    void pack_into(uint8_t* buffer_ptr) const
    {
{% for field in fields if field.enabled and field.packed_tag.packed_int is none %}
{%   if field.is_list %}
        for (const auto{{ '&' if not type_helper.is_scalar(field.type_) }} elem : _{{ field.name }}) {
{%     if type_helper.is_scalar(field.type_) %}
            static_assert(std::is_trivially_copyable_v<decltype(elem)>);
            std::memcpy(buffer_ptr, &elem, sizeof(elem));
            buffer_ptr += sizeof(elem);
{%     else %}
            elem.pack_into(buffer_ptr);
            buffer_ptr += elem.size();
{%     endif %}
        }
{%   elif type_helper.is_scalar(field) %}
{%      if not field.is_packed_type %}
{%         set field_name = '_' + field.name %}
{%      else %}
{%         set field_name = field.name %}
{%      endif %}
        std::memcpy(buffer_ptr, &{{ field_name }}, sizeof({{ field_name }}));
{%     if not loop.last %}
        buffer_ptr += sizeof({{ field_name }});
{%     endif %}
{%   else %}
        _{{ field.name }}.pack_into(buffer_ptr);
{%     if not loop.last %}
        buffer_ptr += _{{ field.name }}.size();
{%     endif %}
{%   endif %}
{% endfor %}
    }

    void unpack_from(const uint8_t* data)
    {
        auto* ptr = data;
{% for field in fields if field.enabled and field.packed_tag.packed_int is none %}
{%   if field.is_list %}
        _{{ field.name}}.resize({{ field.linked_size.getter }}());
        for (size_t i=0; i<_{{ field.name }}.size(); ++i) {
{%     if type_helper.is_scalar(field.type_) %}
            std::memcpy(_{{ field.name }}.data() + i, ptr, sizeof(_{{ field.name }}[i]));
            ptr += sizeof(_{{ field.name }}[i]);
{%     else %}
            _{{ field.name}}[i].unpack_from(ptr);
            ptr += _{{ field.name }}[i].size();
{%     endif %}
        }
{%  elif type_helper.is_scalar(field) %}
{%      if not field.is_packed_type %}
{%         set field_name = '_' + field.name %}
{%      else %}
{%         set field_name = field.name %}
{%      endif %}
        std::memcpy(&{{ field_name }}, ptr, sizeof({{ field_name }}));
{%     if not loop.last %}
        ptr += sizeof({{ field_name }});
{%     endif %}
{%   else %}
        _{{ field.name }}.unpack_from(ptr);
{%     if not loop.last %}
        ptr += _{{ field.name }}.size();
{%     endif %}
{%   endif %}
{% endfor %}
    }
{% endif %}

private:
{% for field in fields if field.enabled and not field.is_packed_type %}
{%     if loop.first %}
    /*
{%     endif %}
     * {{ field.name }} {{ field.packed_tag.field_word }}/{{ field.packed_tag.position }} 
{%     if loop.last %}
     */
{%     endif %}
{% endfor %}
{% for field in fields if field.enabled %}
{%     set tag = field.packed_tag %}
{%     if class.is_template %}
{%         if field.type_.is_packed_struct %}
    {{ type_helper.member_type(field) }} _{{ field.name }};
{%         else %}
    T _{{field.name}};
{%         endif %}
{%     elif tag.packed_int is none %}
    {{ basic.member(field, type_helper) | indent(4) | trim }}
{%     endif %}
{% endfor %}

}; // end class {{ class.type_ }}

{%- endmacro %}