/*#
 * Copyright (C) 2022 Geon Technologies, LLC
 *
 * This file is part of vrtgen.
 *
 * vrtgen is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * vrtgen is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
#*/
{%- import "macros/function_defs.jinja2" as function_defs %}
{%- from "macros/function_defs/bytes_required.jinja2" import bytes_required %}
{%- from "macros/function_defs/match.jinja2" import match %}
{%- import "macros/function_defs/constructors.jinja2" as constructors %}

{%- macro update_positions(packet, type_helper) %}
{% set ns = namespace(curr_pos=0) %}
void {{ packet.name }}::update_positions()
{
{% if packet.cif0.enabled %}
{%   for field in packet.cif0.fields if field.enabled and not field.indicator_only %}
{%     if loop.first %}
    std::size_t curr_pos{ m_positions["{{ packet.cif0.name }}"] + m_{{ packet.cif0.name }}.size() };
{%     endif %}
    m_positions["{{ field.name }}"] = curr_pos;
{%     if field.is_optional %}
    if (m_{{ packet.cif0.name }}.{{ field.name }}()) {
{%       if type_helper.is_scalar(field) %}
        curr_pos += sizeof({{ type_helper.member_type(field) }});
{%       else %}
        curr_pos += m_{{ field.name }}->size();
{%       endif %}
    }
{%     endif %}
{%   endfor %}
{% endif %}
}
{% endmacro %}

{%- macro sync(packet, type_helper) %}
void {{ packet.name }}::sync()
{
{% if packet.cif0.enabled %}
{%   for field in packet.cif0.fields if field.enabled and not type_helper.is_scalar(field) %}
{%     if field.is_optional %}
    m_{{ field.name }}->pack_into(m_data.data() + m_positions.at("{{ field.name }}"));
{%     else %}
    m_{{ field.name }}.pack_into(m_data.data() + m_positions.at("{{ field.name }}"));
{%     endif %}
{%   endfor %}
{% endif %}
{% if packet.is_data and packet.trailer.enabled %}
    m_{{ packet.trailer.name }}.pack_into(m_data.data() + m_positions.at("{{ packet.trailer.name }}"));
{% endif %}
}
{% endmacro %}

{%- macro packet_functions(packet, type_helper) %}
/**
 * {{ packet.name }} class functions
 */
{{ constructors.constructor(packet, type_helper) | trim }}

{{ constructors.unpack_constructor(packet, type_helper) | trim }}

std::string {{ packet.name }}::name() const
{
    return m_name;
}

{{ match(packet, type_helper) | trim }}

{{ function_defs.prologue(packet, type_helper) | trim }}

{% if packet.is_command %}
{{ function_defs.command(packet, type_helper) | trim }}

{% endif %}
{% if packet.is_context or packet.is_command %}
{{ function_defs.cif(packet, type_helper) | trim }}

{% endif %}
{% if packet.is_data %}
{{ function_defs.data(packet, type_helper) | trim }}

{% endif %}
std::span<const uint8_t> {{ packet.name }}::data()
{
    sync();
    return { m_data.data(), m_data.size() };
}

std::size_t {{ packet.name }}::size() const
{
    return m_data.size();
}

void {{ packet.name }}::update_packet_size()
{
    m_header.packet_size(static_cast<uint16_t>((m_data.size() + 3) / 4));
    m_header.pack_into(m_data.data());
}

{{ update_positions(packet, type_helper) | trim }}

{{ bytes_required(packet, type_helper) | trim}}

{{ sync(packet, type_helper) | trim }}
{% endmacro %}

{%- macro define_source() %}
#include <vrtgen/buffer.hpp>
#include "{{ header }}"

{% if project_name %}
using namespace {{ project_name }}::packets;

{% endif %}

{% for packet in packets %}
{{ packet_functions(packet, type_helper) | trim }}

{% endfor %}
{% endmacro %}
{{ define_source() }}